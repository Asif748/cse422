# -*- coding: utf-8 -*-
"""CSE422_13_Assignment02_Summer2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K4SdZ_c88BPdf1_gCwsgtwjF7s4RmO5J
"""

import random

class Chromosome:
    def __init__(self, chromosome_str):
        self.stop_loss = int(chromosome_str[:2])
        self.take_profit = int(chromosome_str[2:4])
        self.trade_size = int(chromosome_str[4:])

    def ret_chromosome(self):
        return f"{self.stop_loss:02}{self.take_profit:02}{self.trade_size:02}"

def initialize_population(x):
    population = []
    for i in range(4):
        s = ""
        for j in range(6):
            s += str(random.randint(0, 9))
        population.append(Chromosome(s))
    return population

def evaluate_fitness(classcall, historical_prices):
    a = 1000
    daily_summaries = []
    day = 1

    for b in historical_prices:
        c = (classcall.trade_size / 100) * a
        profit_loss = (b / 100) * c
        a += profit_loss

        daily_summaries.append({
            "Day": day,
            "Price Change (%)": b,
            "Trade Size ($)": round(c, 2),
            "Profit/Loss ($)": round(profit_loss, 2),
            "Updated Capital ($)": round(a, 2)
        })

        day += 1

    return a - 1000, daily_summaries


def parent_selection(population, historical_prices):
    fitness_values = []
    for ind in population:
        fitness, _ = evaluate_fitness(ind, historical_prices)
        fitness_values.append(fitness)
    total_fit = sum(fitness_values)
    if total_fit == 0:
        total_fit = 1
    probabilities = []
    for f in fitness_values:
        probabilities.append(f / total_fit)
    selected_parents = random.choices(population, weights=probabilities, k=2)
    return selected_parents

def two_point_crossover(parent1, parent2):
    parent1_str = parent1.ret_chromosome()
    parent2_str = parent2.ret_chromosome()

    length = len(parent1_str)
    first_point = random.randint(1, length - 2)
    second_point = random.randint(first_point + 1, length - 1)

    child1 = []
    child2 = []

    for i in range(length):
        if first_point <= i < second_point:
            child1.append(parent2_str[i])
            child2.append(parent1_str[i])
        else:
            child1.append(parent1_str[i])
            child2.append(parent1_str[i])

    return "".join(child1), "".join(child2)

def mutate(strategy, mutation_rate=0.05):
    if isinstance(strategy, str):
        strategy = Chromosome(strategy)

    chromosome_list = list(strategy.ret_chromosome())

    if random.random() < mutation_rate:
        mutate_index = random.randint(0, len(chromosome_list) - 1)
        chromosome_list[mutate_index] = str(random.randint(0, 9))

    mutated_chromosome = "".join(chromosome_list)
    return Chromosome(mutated_chromosome)

def genetic_algorithm(historical_prices, generations=10, population_size=4):
    population = initialize_population(population_size)

    for gen in range(generations):
        print(f"\nGeneration {gen + 1}:")

        for i in population:
            print("Chromosome:", i.ret_chromosome())

    for _ in range(generations):
        fitness_values = []
        for ind in population:
            fitness, _ = evaluate_fitness(ind, historical_prices)
            fitness_values.append(fitness)
        sorted_population = []
        while len(fitness_values) > 0:
            max_fitness = max(fitness_values)
            max_index = fitness_values.index(max_fitness)
            sorted_population.append(population[max_index])
            fitness_values.pop(max_index)
            population.pop(max_index)
        new_population = sorted_population[:2]
        for i in range(2, population_size, 2):
            parent1 = sorted_population[i]
            if i + 1 < len(sorted_population):
                parent2 = sorted_population[i + 1]
            else:
                parent2 = sorted_population[i]
            child1, child2 = two_point_crossover(parent1, parent2)
            mutated_child1 = mutate(child1)
            mutated_child2 = mutate(child2)
            new_population.append(mutated_child1)
            new_population.append(mutated_child2)
        population = new_population

    best_strategy = population[0]
    best_fitness, daily_summaries = evaluate_fitness(best_strategy, historical_prices)
    for individual in population:
        fitness, _ = evaluate_fitness(individual, historical_prices)
        if fitness > best_fitness:
            best_fitness = fitness
            best_strategy = individual
            daily_summaries = evaluate_fitness(individual, historical_prices)[1]


    print("\nDaily Summaries:")
    print(f"{'Day'}  {'Price Change (%)'}  {'Trade Size ($)'}  {'Profit/Loss ($)'}  {'Updated Capital ($)'}")
    for summary in daily_summaries:
        print(f"{summary['Day']}         {summary['Price Change (%)']}               {summary['Trade Size ($)']}          {summary['Profit/Loss ($)']}              {summary['Updated Capital ($)']}")

    return best_strategy, best_fitness

historical_prices = [-1.2, 3.4, -0.8, 2.1, -2.5, 1.7, -0.3, 5.8, -1.1, 3.5]

best_strategy, final_profit = genetic_algorithm(historical_prices)
print("\nBest Strategy:", "stop loss:", best_strategy.stop_loss, "Take profit:", best_strategy.take_profit, "Trade size:", best_strategy.trade_size)
print("Final Profit:", final_profit)







#Task_02
def two_point_crossover(parent1, parent2):
    length = len(parent1)
    first_point = random.randint(1, length - 2)
    second_point = random.randint(first_point + 1, length - 1)
    child1 = []
    child2 = []
    for i in range(length):
        if first_point <= i < second_point:
            child1.append(parent2[i])
            child2.append(parent1[i])
        else:
            child1.append(parent1[i])
            child2.append(parent2[i])
    return "".join(child1), "".join(child2)
parent1 = "000111000"
parent2 = "111000111"
child1, child2 = two_point_crossover(parent1, parent2)







print(child1)
print(child2)