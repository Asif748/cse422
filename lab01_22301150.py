# -*- coding: utf-8 -*-
"""Lab01_22301150.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tGJpM4IZXhR0RH-8kLI6lbf7CSNTt73Z
"""

with open("inputfile01.txt") as inputs:
    all_paths= {}
    h= {}

    for line in inputs:
        parts = line.split()
        if len(parts) < 2:
            continue
        node, heuristic = parts[:2]
        h[node] = int(heuristic)
        all_paths[node] = []
        for i in range(2, len(parts), 2):
            all_paths[node].append((parts[i], int(parts[i + 1])))
class AStar:
    def __init__(self, all_paths, h):
        self.heuristic = h
        self.all_paths = all_paths

    def h(self, node):
        return self.heuristic.get(node, float('inf'))

    def get_neighbors(self, node):
        return self.all_paths.get(node, [])

    def a_star_algorithm(self, start, goal):
        open_set = set([start])
        closed_set = set()
        g_score = {start: 0}
        parent = {start: None}

        while open_set:
            current = None
            min_f_score = float('inf')

            for node in open_set:
                f_score = g_score[node] + self.h(node)
                if f_score < min_f_score:
                    min_f_score = f_score
                    current = node

            if current == goal:
                path = []
                total_distance = g_score[current]

                while current:
                    path.append(current)
                    current = parent[current]

                path.reverse()
                path_str = " -> ".join(path)
                print(f"Path: {path_str}")
                print(f"Total Distance: {total_distance} km")

                with open("output.txt", "a") as outputs:
                    outputs.write(f"Path: {path_str}\nTotal Distance: {total_distance} km\n\n")

                return path, total_distance

            open_set.remove(current)
            closed_set.add(current)

            for neighbor, distance in self.get_neighbors(current):
                if neighbor in closed_set:
                    continue

                tentative_g_score = g_score[current] + distance

                if neighbor not in open_set:
                    open_set.add(neighbor)
                elif tentative_g_score >= g_score.get(neighbor, float('inf')):
                    continue

                parent[neighbor] = current
                g_score[neighbor] = tentative_g_score

        print("Path does not exist!")
        return None

start_node = input("Start Node: ")
goal_node = input("Destination Node: ")
astar = AStar(all_paths, h)
astar.a_star_algorithm(start_node, goal_node)